// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc3244.MechanicalMayham;

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import edu.wpi.first.wpilibj.ADXRS450_Gyro;
import edu.wpi.first.wpilibj.AnalogPotentiometer;
import edu.wpi.first.wpilibj.BuiltInAccelerometer;
import edu.wpi.first.wpilibj.DigitalInput;
import edu.wpi.first.wpilibj.Relay;
import edu.wpi.first.wpilibj.Servo;
import edu.wpi.first.wpilibj.Spark;
import edu.wpi.first.wpilibj.SpeedController;
import edu.wpi.first.wpilibj.Timer;
import edu.wpi.first.wpilibj.VictorSP;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS

//Manually Configured Imports
import edu.wpi.first.wpilibj.SerialPort;
import edu.wpi.first.wpilibj.I2C;
import edu.wpi.first.wpilibj.DriverStation;
import edu.wpi.first.wpilibj.livewindow.LiveWindow;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

import com.ctre.phoenix.motorcontrol.FeedbackDevice;
import com.ctre.phoenix.motorcontrol.can.WPI_TalonSRX;
import com.kauailabs.navx.frc.AHRS;

/**
 * The RobotMap is a mapping from the ports sensors and actuators are wired into
 * to a variable name. This provides flexibility changing wiring, makes checking
 * the wiring easier and significantly reduces the number of magic numbers
 * floating around.
 */
public class RobotMap {
	
	
	
	public static WPI_TalonSRX drivemotor_Front_Left;
    public static WPI_TalonSRX drivemotor_Front_Right;
    public static WPI_TalonSRX drivemotor_Back_Left;
    public static WPI_TalonSRX drivemotor_Back_Right;
    public static BuiltInAccelerometer roboRioAccelerometer ; 
    
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    public static SpeedController winchmotor_Winch;
    public static DigitalInput winchlimitSwitch_Left;
    public static DigitalInput winchlimitSwitch_Right;
    public static SpeedController fuelIntakemotor_IntakeRoller;
    public static AnalogPotentiometer wristPot;
    public static SpeedController wristmotor;
    public static SpeedController flyWheelmotor_Indexer;
    public static WPI_TalonSRX flyWheelmotor_FlyWheel;
    public static Relay vision_hardwarelights_Left_and_Forward;
    public static Relay vision_hardwarelights_Right;
    public static Servo elevatorServoservo_Elevator;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    
    public static DigitalInput functionJumpperVision;
    public static AHRS ahrs;
    public static ADXRS450_Gyro adrxs450_Gyro;
    
    //PDP Channles
    public static final int DRIVE_BACK_RIGHT_PDP = 0;
	public static final int DRIVE_FRONT_RIGHT_PDP = 1;
	public static final int WINCH_PDP = 2;
	public static final int NC3 = 3;
	public static final int WRIST_PDP = 4;
	public static final int KANGAROO_POWER_PDP = 5;
	public static final int VOLTMETER_PDP = 6;
	public static final int NC7_PDP = 7;
	public static final int LIGHTS_SPIKE1_PDP = 8;
	public static final int LIGHTS_SPIKE2_PDP = 9;
	public static final int INTAKE_PDP = 10;
	public static final int FUEL_INDEXER_PDP = 11;
	public static final int NC12_PDP = 12;
	public static final int DRIVE_FRONT_LEFT_PDP = 13;
	public static final int FLYWHEEL_PDP = 14;
	public static final int DRIVE_BACK_LEFT_PDP = 15;
	
	//public static boolean isCompetitionBot = true;
    public static boolean isCompetitionBot = true;
	private static boolean MISSING_METHOD; 
    
	//Start Code to use the NorticSpeedControler
    public enum RobotDriveTrainSettings {
    	FORWARD_BACKWARD_FACTOR(1,.5),
    	ROTATION_FACTOR(1.25,.5),
     	STRAFE_FACTOR(2,.75);
	
		private final double m_competitionSetting;
		private final double m_practiceSetting;
		
		public double get() {
			return isCompetitionBot ? m_competitionSetting : m_practiceSetting; 
		}
		
		RobotDriveTrainSettings(double competitionSetting, double practiceSetting) {
	    	m_competitionSetting = competitionSetting;
	    	m_practiceSetting = practiceSetting;
		}
	}
	
	static void init() { 
		
		roboRioAccelerometer = new BuiltInAccelerometer();
		
		//Not Letting RobotBuilder Manage These Anymore
		drivemotor_Front_Left = new WPI_TalonSRX(2);//1);
        LiveWindow.addActuator("Drive", "motor_Front_Left", drivemotor_Front_Left);
        
        drivemotor_Front_Right = new WPI_TalonSRX(4);//2);
        LiveWindow.addActuator("Drive", "motor_Front_Right", drivemotor_Front_Right);
        
        drivemotor_Back_Left = new WPI_TalonSRX(1);//3);
        LiveWindow.addActuator("Drive", "motor_Back_Left", drivemotor_Back_Left);
        
        drivemotor_Back_Right = new WPI_TalonSRX(3);//4);
        LiveWindow.addActuator("Drive", "motor_Back_Right", drivemotor_Back_Right);
        
        
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        winchmotor_Winch = new VictorSP(1);
        LiveWindow.addActuator("Winch", "motor_Winch", (VictorSP) winchmotor_Winch);
        
        winchlimitSwitch_Left = new DigitalInput(0);
        LiveWindow.addSensor("Winch", "limitSwitch_Left", winchlimitSwitch_Left);
        
        winchlimitSwitch_Right = new DigitalInput(1);
        LiveWindow.addSensor("Winch", "limitSwitch_Right", winchlimitSwitch_Right);
        
        fuelIntakemotor_IntakeRoller = new VictorSP(2);
        LiveWindow.addActuator("Fuel Intake", "motor_IntakeRoller", (VictorSP) fuelIntakemotor_IntakeRoller);
        
        wristPot = new AnalogPotentiometer(2, 270.0, -82.3);
        LiveWindow.addSensor("Wrist", "Pot", wristPot);
        
        wristmotor = new Spark(3);
        LiveWindow.addActuator("Wrist", "motor", (Spark) wristmotor);
        
        flyWheelmotor_Indexer = new VictorSP(5);
        LiveWindow.addActuator("FlyWheel", "motor_Indexer", (VictorSP) flyWheelmotor_Indexer);
        
        flyWheelmotor_FlyWheel = new WPI_TalonSRX(5);
        LiveWindow.addActuator("FlyWheel", "motor_FlyWheel", flyWheelmotor_FlyWheel);
        
        vision_hardwarelights_Left_and_Forward = new Relay(0);
        LiveWindow.addActuator("Vision_hardware", "lights_Left_and_Forward", vision_hardwarelights_Left_and_Forward);
        
        vision_hardwarelights_Right = new Relay(1);
        LiveWindow.addActuator("Vision_hardware", "lights_Right", vision_hardwarelights_Right);
        
        elevatorServoservo_Elevator = new Servo(4);
        LiveWindow.addActuator("ElevatorServo", "servo_Elevator", elevatorServoservo_Elevator);
        

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        // Some DIO To Work with
        functionJumpperVision = new DigitalInput(9);
        LiveWindow.addSensor("Function_Jumpers", "Vision", functionJumpperVision);
        
        // Invert Motors
        fuelIntakemotor_IntakeRoller.setInverted(true);
        winchmotor_Winch.setInverted(true);
        flyWheelmotor_Indexer.setInverted(true);
        
        // Invert Encoders
      
        /* first choose the sensor */
       
        flyWheelmotor_FlyWheel.configSelectedFeedbackSensor(FeedbackDevice.QuadEncoder, 0, 0);
        
        //flyWheelmotor_FlyWheel.reverseSensor(true);
        flyWheelmotor_FlyWheel.setSensorPhase(true);
        
        //flyWheelmotor_FlyWheel.configEncoderCodesPerRev(80); // if using FeedbackDevice.QuadEncoder
        MISSING_METHOD = true;
        //_talon.configPotentiometerTurns(XXX), // if using FeedbackDevice.AnalogEncoder or AnalogPot

        /* set the peak and nominal outputs, 12V means full */
        //flyWheelmotor_FlyWheel.configNominalOutputVoltage(+0.0f, -0.0f);
        flyWheelmotor_FlyWheel.configNominalOutputForward(0, 0);
        flyWheelmotor_FlyWheel.configNominalOutputReverse(0, 0);
        //flyWheelmotor_FlyWheel.configPeakOutputVoltage(+12.0f, -0.0f);
        flyWheelmotor_FlyWheel.configPeakOutputForward(1.0, 0); //(double percentOut, int timeoutMs)
        flyWheelmotor_FlyWheel.configPeakOutputReverse(1.0, 0); //(double percentOut, int timeoutMs)
        /* set closed loop gains in slot0 */
        //* flyWheelmotor_FlyWheel.setProfile(0);
        flyWheelmotor_FlyWheel.selectProfileSlot(0, 0); //(int slotIdx, int pidIdx) slotIdx - Profile slot to select. pidIdx - 0 for Primary closed-loop. 1 for cascaded closed-loop.
        //*flyWheelmotor_FlyWheel.setF(2.13);
        flyWheelmotor_FlyWheel.config_kF(0, 2.14, 0); //(int slotIdx, double value, int timeoutMs)
        //*flyWheelmotor_FlyWheel.setP(0);
        flyWheelmotor_FlyWheel.config_kP(0, 0, 0); //(int slotIdx, double value, int timeoutMs)
        //*flyWheelmotor_FlyWheel.setI(0); 
        flyWheelmotor_FlyWheel.config_kI(0, 0, 0); //(int slotIdx, double value, int timeoutMs)
        //*flyWheelmotor_FlyWheel.setD(0);
        flyWheelmotor_FlyWheel.config_kD(0, 0, 0); //(int slotIdx, double value, int timeoutMs)
        //flyWheelmotor_FlyWheel.changeControlMode(TalonControlMode.Speed);
        //No longer used it is tied to the .set()
        //*flyWheelmotor_FlyWheel.setVoltageRampRate(24.0);
        flyWheelmotor_FlyWheel.configClosedloopRamp(2, Robot.M_WPI_TalonSRX_config_TimeoutMs);
        
        //Create Gyro
        try {
        	System.out.println("Hello Tying to INIT Navx");
            /* Communicate w/navX MXP via the MXP SPI Bus.                                     */
            /* Alternatively:  I2C.Port.kMXP, SerialPort.Port.kMXP or SerialPort.Port.kUSB     */
            /* See http://navx-mxp.kauailabs.com/guidance/selecting-an-interface/ for details. */
        
            //ahrs = new AHRS(SPI.Port.kMXP); 
        	//ahrs = new AHRS(I2C.Port.kMXP);
        	ahrs = new AHRS(SerialPort.Port.kUSB);
            //ahrs = new AHRS(I2C.Port.kOnboard); 
        	//ahrs = new AHRS(I2C.Port.kOnboard,(byte)200);
            
        } catch (RuntimeException ex ) {
        	System.out.println("Hello from the Navx runtimeExcept");
            DriverStation.reportError("Error instantiating navX MXP:  " + ex.getMessage(), true);
        }
        
        try{
        	DriverStation.reportWarning("Init ADXRS450_Gyro", false);
        	adrxs450_Gyro = new ADXRS450_Gyro();
        }catch (RuntimeException ex ) {
        	System.out.println("Hello from the adrxs450_Gyro runtimeExcept");
            DriverStation.reportError("Error instantiating adrxs450_Gyro:  " + ex.getMessage(), true);
        }
            Timer.delay(2);
    }
}
